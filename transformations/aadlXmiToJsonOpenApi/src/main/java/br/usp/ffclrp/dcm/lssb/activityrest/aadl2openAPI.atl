-- @nsURI aadl=http://dcm.ffclrp.usp.br/lssb/metamodels/analysis-activity-description.ecore
-- @nsURI slm=http://dcm.ffclrp.usp.br/lssb/metamodels/string-list-manipulator.ecore
-- @nsURI openapi=http://som.uoc.edu/openapi/2.0.0


module aadl2openAPI;
create OUT: openapi from IN: aadl;

helper def: port(): Integer =
	8081;

helper def: host(): String =
	'kode.ffclrp.usp.br:' + thisModule.port();

helper def: basePath(path: String): String =
	'/' + path ;

helper def: apiVersion(): String =
	'0.8.0';

helper def: contact(): String =
	'ricardo.cawal@gmail.com';

helper def: definitions : Set(openapi!Schema) = OclUndefined;



rule Activity {
	from
		activity: aadl!Activity in IN
	using {
	
	}
	to
		root : openapi!Root (
			schemas <- schema,
			api <-api,
			paramters <- OclUndefined,
			responses <- OclUndefined
		),
		schema : openapi!Schema (
			title <- activity.name,
			description <- activity.remark
		),
		api: openapi!API (
			swagger <- '2.0',
			host <- thisModule.host(),
			basePath <- thisModule.basePath(activity.name),
			schemes <- 'http',
			consumes <- 'application/json',
			consumes <- 'application/xml',
			produces <- 'application/json',
			produces <- 'application/xml',
			info <- apiInfo,
--			paths <- activity.parameters
			paths <- thisModule.activityEndpoints(activity),
			paths <- activity.parameters->collect(e 
			    | thisModule.parameterEndpoints(e))
			    ->flatten(),
--			paths <- openapi!Path.allInstances(),
			paths <- activity.inputDatasets,
			paths <- activity.outputDatasets,
			definitions <-activityDefinition,
			definitions <- parameterMapDefiniton,
			definitions <- fileDefinition,
			definitions <- jobInstanceDefinition,
			definitions <- parameterRepresentation,
			definitions <- thisModule.definitions.debug()
		),
		apiInfo: openapi!Info (
			description <- activity.remark,
			title <- activity.name,
			version <- thisModule.apiVersion(),
			license <- OclUndefined,
			termsOfService <- ''
		),
		activityDefinition: openapi!Schema (
			referenceName <- 'AnalysisActivity',
			type <- #object,
			properties <- analysisIdProperty,
			properties <- analysisStateProperty,
			properties <- errorReportProperty,
			required <- analysisIdProperty
		),
		analysisIdProperty: openapi!Property (
			referenceName <- 'id',
			schema <- stringSchema
		),
		analysisStateProperty: openapi!Property (
			referenceName <- 'state',
			schema <- stateSchema 
		),
		errorReportProperty: openapi!Property (
		    referenceName <- 'errorReport',
		    schema <- stringSchema
		),
		jobInstanceDefinition: openapi!Schema (
			referenceName <- 'JobInstance',
			type <- #object,
			properties <- jobIdProperty,
			properties <- jobStateProperty,
			properties <- jobErrorReportProperty,
			required <- jobIdProperty
		),
		jobIdProperty: openapi!Property (
			referenceName <- 'id',
			schema <- stringSchema
		),
		jobStateProperty: openapi!Property (
			referenceName <- 'state',
			schema <- stateSchema 
		),
		jobErrorReportProperty: openapi!Property (
		    referenceName <- 'errorReport',
		    schema <- stringSchema
		),
		parameterRepresentation: openapi!Schema (
		    referenceName <- 'Parameter',
		    properties <- parameterNameProperty,
		    properties <- parameterValueProperty,
		    required <- parameterNameProperty,
		    required <- parameterValueProperty
		),
		parameterNameProperty : openapi!Property (
			referenceName <- 'name',
			schema <- stringSchema
		),
		parameterValueProperty: openapi!Property (
		    referenceName <- 'value',
		    schema <- parameterValueSchema
		),
		parameterValueSchema: openapi!Schema (
			type <- #array,
			items <- genericParameterValueSchema
		),
		parameterMapDefiniton: openapi!Schema (
			referenceName <- 'Parameters',
			type <- #object
		),
		fileDefinition: openapi!Schema (
			referenceName <- 'File',
			properties <- nameProperty,
			properties <- contentTypeProperty,
			properties <- fileContentProperty
		),
		nameProperty : openapi!Property (
			referenceName <- 'name',
			schema <- stringSchema
		),
		contentTypeProperty : openapi!Property (
			referenceName <- 'contentType',
			schema <- stringSchema
		),
		fileContentProperty : openapi!Property (
			referenceName <- 'content',
			schema <- fileContentsSchema
		),
		stringSchema: openapi!Schema (
			type <- #string
		),
		stateSchema: openapi!Schema (
			type <- #string,
			enum <- 'CREATED',
			enum <- 'READY',
			enum <- 'RUNNING',
			enum <- 'SUCCEEDED',
			enum <- 'FAILED',
			enum <- 'REMOVED'
		),
		fileContentsSchema : openapi!Schema (
			type <- #string,
			format <- 'application/octet-stream'
		),
		genericParameterValueSchema : openapi!Schema (
			type <- #unspecified
		)
	do {
--		root.paramters <- openapi!Parameter.allInstances();
	}
}

--rule Parameter {
--	from
--		parameter: aadl!Parameter 
--	to
--		nonExecutedAnalysisPath: openapi!Path (
--			relativePath <- '/new-analyses/{id}/parameters/' + parameter.name,
--			parameters <- activityIdentifier,
--			get <- getNewAnalysis,
--			put <- putNewAnalysis
--		),
--		succeededAnalysisPath: openapi!Path (
--			relativePath <- '/succeded-analyses/{id}/parameters/' + parameter.name,
--			parameters <- activityIdentifier,
--			get <- getSucceededAnalysis
--		),
--		failedAnalysisPath: openapi!Path (
--			relativePath <- '/failed-analyses/{id}/parameters/' + parameter.name,
--			parameters <- activityIdentifier,
--			get <- getFailedAnalysis
--		),
--		activityIdentifier: openapi!Parameter (
--			name <- 'id',
--			type <- 'string',
--			required <- true,
--			description <- 'The analysis activity identifier.',
--			location <- #path
--		),
--		getNewAnalysis : openapi!Operation (
--			operationId <- 'get-' + parameter.name + 'from-non-executed-analysis',
--			description <- parameter.remark,
--			parameters <- activityIdentifier,
--			responses <- okResponse			
--		),
--		getSucceededAnalysis : openapi!Operation (
--			operationId <- 'get-' + parameter.name + 'from-succeded-analysis',
--			description <- parameter.remark,
--			parameters <- activityIdentifier,
--			responses <- okResponse			
--		),
--		getFailedAnalysis : openapi!Operation (
--			operationId <- 'get-' + parameter.name + 'from-failed-analysis',
--			description <- parameter.remark,
--			parameters <- activityIdentifier,
--			responses <- okResponse			
--		),
--		putNewAnalysis : openapi!Operation (
--			operationId <- 'put-' + parameter.name + 'for-non-executed-analysis',
--			description <- parameter.remark,
--			parameters <- activityIdentifier,
--			responses <- okResponse			
--		),
--		okResponse: openapi!Response (
--			code <- '200',
--			description <- 'Parameter value is retrieved'
--		)
--		do {
--		}
--}


--- Several endpoints are created from a single Activity element,
--- thus we use a called rule that returns a Sequence in the do{}
--- section.
rule activityEndpoints(activity: aadl!Activity) {
    to
    	rootPath: openapi!Path (
			relativePath <- '/',
			get <- getRoot
		),
    	newAnalysisCollectionPath: openapi!Path (
			relativePath <- '/new-analyses',
			post <- createNewAnalysis
		),
		nonExecutedAnalysisPath: openapi!Path (
			relativePath <- '/new-analyses/{id}',
			parameters <- activityIdentifier,
			get <- getNewAnalysis,
			delete <- deleteNewAnalysis
		),
		succededAnalysisPath: openapi!Path (
			relativePath <- '/succeded-analyses/{id}',
			parameters <- activityIdentifier,
			get <- getSuccededAnalysis,
			delete <- deleteSuccededAnalysis
		),
		failedAnalysisPath: openapi!Path (
			relativePath <- '/failed-analyses/{id}',
			parameters <- activityIdentifier,
			get <- getFailedAnalysis,
			delete <- deleteFailedAnalysis
		),
		activityIdentifier: openapi!Parameter (
			name <- 'id',
			type <- 'string',
			required <- true,
			description <- 'The analysis activity identifier.',
			location <- #path
		),
		getRoot : openapi!Operation (
			operationId <- 'get-service-root-resource',
			description <- activity.remark,
			responses <- okResponse			
		),
		createNewAnalysis : openapi!Operation (
			operationId <- 'create-new-analysis-resource',
			description <- activity.remark,
			responses <- okResponse
		),
		getNewAnalysis : openapi!Operation (
			operationId <- 'get-non-executed-analysis',
			description <- activity.remark,
			parameters <- activityIdentifier,
			responses <- okResponse			
		),
		deleteNewAnalysis : openapi!Operation (
			operationId <- 'remove-non-executed-analysis',
			description <- activity.remark,
			parameters <- activityIdentifier,
			responses <- deleteOkResponse			
		),		
		getSuccededAnalysis : openapi!Operation (
			operationId <- 'get-succeeded-analysis',
			description <- activity.remark,
			parameters <- activityIdentifier,
			responses <- okResponse			
		),
		deleteSuccededAnalysis : openapi!Operation (
			operationId <- 'remove-succeded-analysis',
			description <- activity.remark,
			parameters <- activityIdentifier,
			responses <- deleteOkResponse			
		),		
		getFailedAnalysis : openapi!Operation (
			operationId <- 'get-failed-analysis',
			description <- activity.remark,
			parameters <- activityIdentifier,
			responses <- okResponse			
		),
		deleteFailedAnalysis : openapi!Operation (
			operationId <- 'remove-failed-analysis',
			description <- activity.remark,
			parameters <- activityIdentifier,
			responses <- deleteOkResponse			
		),
		okResponse: openapi!Response (
			code <- '200',
			description <- 'Analysis activity representation is retrieved'
		),
		deleteOkResponse: openapi!Response (
			code <- '200',
			description <- 'Analysis activity is removed from server.'
		)
    do {
        Sequence{
            rootPath,
            newAnalysisCollectionPath,
            nonExecutedAnalysisPath,
            succededAnalysisPath,
            failedAnalysisPath
        };
    }
}



--- Several endpoints are created from a single Parameter element,
--- thus we use a called rule that returns a Sequence in the do{}
--- section.
rule parameterEndpoints(parameter: aadl!Parameter) {
	to
		nonExecutedAnalysisPath: openapi!Path (
			relativePath <- '/new-analyses/{id}/parameters/' + parameter.name,
			parameters <- activityIdentifier,
			get <- getNewAnalysis,
			put <- putNewAnalysis
		),
		succeededAnalysisPath: openapi!Path (
			relativePath <- '/succeded-analyses/{id}/parameters/' + parameter.name,
			parameters <- activityIdentifier,
			get <- getSucceededAnalysis
		),
		failedAnalysisPath: openapi!Path (
			relativePath <- '/failed-analyses/{id}/parameters/' + parameter.name,
			parameters <- activityIdentifier,
			get <- getFailedAnalysis
		),
		activityIdentifier: openapi!Parameter (
			name <- 'id',
			type <- 'string',
			required <- true,
			description <- 'The analysis activity identifier.',
			location <- #path
		),
		getNewAnalysis : openapi!Operation (
			operationId <- 'get-' + parameter.name + 'from-non-executed-analysis',
			description <- parameter.remark,
			parameters <- activityIdentifier,
			responses <- okResponse			
		),
		getSucceededAnalysis : openapi!Operation (
			operationId <- 'get-' + parameter.name + 'from-succeded-analysis',
			description <- parameter.remark,
			parameters <- activityIdentifier,
			responses <- okResponse			
		),
		getFailedAnalysis : openapi!Operation (
			operationId <- 'get-' + parameter.name + 'from-failed-analysis',
			description <- parameter.remark,
			parameters <- activityIdentifier,
			responses <- okResponse			
		),
		putNewAnalysis : openapi!Operation (
			operationId <- 'put-' + parameter.name + 'for-non-executed-analysis',
			description <- parameter.remark,
			parameters <- activityIdentifier,
			responses <- okResponse			
		),
		okResponse: openapi!Response (
			code <- '200',
			description <- 'Parameter value is retrieved'
		)
		do {
		    Sequence{
		        nonExecutedAnalysisPath,
		        succeededAnalysisPath,
		        failedAnalysisPath
		    };
		}
}

rule InputDatasetSingleFile {
	from
		dataset: aadl!InputDataset ( 1 = dataset.maximumCardinality.debug())

	to 
		nonExecutedAnalysisPath: openapi!Path (
			relativePath <- '/new-analyses/{id}/inputs/' + dataset.name,
			parameters <- activityIdentifier,
			get <- getNewAnalysis
		),
		activityIdentifier: openapi!Parameter (
			name <- 'id',
			type <- 'string',
			required <- true,
			location <- #path
		),
		getNewAnalysis : openapi!Operation (
			operationId <- 'get-' + dataset.name + 'from-non-executed-analysis',
			description <- dataset.remark,
			parameters <- activityIdentifier,
			responses <- okResponse			
		),
		okResponse: openapi!Response (
			code <- '200',
			description <- 'Dataset value is retrieved'
		)
}


rule InputDatasetMultipleFile {
	from
		dataset: aadl!InputDataset (not (1 = dataset.maximumCardinality.debug()))

	to 
		nonExecutedAnalysisPath: openapi!Path (
			relativePath <- '/new-analyses/{id}/inputs/' + dataset.name,
			parameters <- activityIdentifier,
			get <- getNewAnalysis
		),
		activityIdentifier: openapi!Parameter (
			name <- 'id',
			type <- 'string',
			required <- true,
			location <- #path
		),
		getNewAnalysis : openapi!Operation (
			operationId <- 'get-' + dataset.name + 'from-non-executed-analysis',
			description <- dataset.remark,
			parameters <- activityIdentifier,
			responses <- okResponse			
		),
		okResponse: openapi!Response (
			code <- '200',
			description <- 'Dataset value is retrieved'
		)
}

rule OutputDatasetSingleFile {
	from
		dataset: aadl!OutputDataset ( 1 = dataset.maximumCardinality.debug())

	to 
		succeededAnalysisPath: openapi!Path (
			relativePath <- '/succeeded-analyses/{id}/outputs/' + dataset.name,
			parameters <- activityIdentifier,
			get <- getFromSuccededAnalysis
		),
		activityIdentifier: openapi!Parameter (
			name <- 'id',
			type <- 'string',
			required <- true,
			location <- #path
		),
		getFromSuccededAnalysis : openapi!Operation (
			operationId <- 'get-' + dataset.name + 'from-succeeded-analysis',
			description <- dataset.remark,
			parameters <- activityIdentifier,
			responses <- okResponse			
		),
		okResponse: openapi!Response (
			code <- '200',
			description <- 'Dataset value is retrieved'
		)
}


rule OutputDatasetMultipleFile {
	from
		dataset: aadl!OutputDataset (not (1 = dataset.maximumCardinality.debug()))

	to 
		succeededAnalysisPath: openapi!Path (
			relativePath <- '/succeeded-analyses/{id}/outputs/' + dataset.name,
			parameters <- activityIdentifier,
			get <- getFromSuccededAnalysis
		),
		activityIdentifier: openapi!Parameter (
			name <- 'id',
			type <- 'string',
			required <- true,
			location <- #path
		),
		getFromSuccededAnalysis : openapi!Operation (
			operationId <- 'get-' + dataset.name + 'from-succeeded-analysis',
			description <- dataset.remark,
			parameters <- activityIdentifier,
			responses <- okResponse			
		),
		okResponse: openapi!Response (
			code <- '200',
			description <- 'Dataset value is retrieved'
		)
}